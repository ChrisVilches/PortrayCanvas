{"version":3,"sources":["webpack:///webpack/bootstrap fff1f018b736de1ebd53","webpack:///./src/drawcanvas.js","webpack:///./src/util.js","webpack:///./src/renderer.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AC7MA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB,EAAE,gBAAgB,EAAE,gBAAgB;AACnE;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChCA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA","file":"drawcanvas.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fff1f018b736de1ebd53","'use strict';\r\n\r\nvar Util = require('./util.js');\r\nvar Renderer = require('./renderer.js');\r\n\r\nmodule.exports = class DrawCanvas {\r\n\r\n  constructor(canvasDOM, options){\r\n\r\n    this.canvas = canvasDOM;\r\n    this.context = this.canvas.getContext('2d');\r\n    this.started = false;\r\n    this.context.lineJoin = 'round';\r\n    this.context.lineCap = 'round';\r\n    this.memCanvas = document.createElement('canvas');\r\n    this.memCanvas.width = this.canvas.width;\r\n    this.memCanvas.height = this.canvas.height;\r\n    this.memCtx = this.memCanvas.getContext('2d');\r\n    this.undoHistory = [];\r\n\r\n    this.renderer = new Renderer(this.canvas);\r\n\r\n    this.init();\r\n    this.setOptions(options);\r\n    this.canvas.addEventListener('mousedown', this.eventCanvas.bind(this), false);\r\n    this.canvas.addEventListener('mousemove', this.eventCanvas.bind(this), false);\r\n    this.canvas.addEventListener('mouseup', this.eventCanvas.bind(this), false);\r\n    this.canvas.addEventListener('mouseout', this.eventCanvas.bind(this), false);\r\n  }\r\n\r\n  setOptions(options){\r\n\r\n    this.context.strokeStyle = Util.rgb2hex(Util.getStyleProp(this.canvas, 'color'));\r\n    this.context.lineWidth = 5;\r\n    this.period = 10;\r\n    this.onFinishLine = null;\r\n    this.onClear = null;\r\n    this.onUndo = null;\r\n\r\n    if(typeof options !== 'object' || options == null) return;\r\n\r\n    if(typeof options.color === 'string')\r\n      this.context.strokeStyle = options.color;\r\n\r\n    if(typeof options.lineWidth === 'number')\r\n      this.context.lineWidth = options.lineWidth;\r\n\r\n    if(typeof options.period === 'number')\r\n      this.period = options.period;\r\n\r\n    if(typeof options.onFinishLine === 'function')\r\n      this.onFinishLine = options.onFinishLine;\r\n\r\n    if(typeof options.onClear === 'function')\r\n      this.onClear = options.onClear;\r\n\r\n    if(typeof options.onUndo === 'function')\r\n      this.onUndo = options.onUndo;\r\n\r\n    this.colorDefault = this.context.strokeStyle;\r\n  }\r\n\r\n  setColor(color){\r\n    this.context.strokeStyle = color;\r\n  }\r\n\r\n  revertDefaultColor(){\r\n    this.context.strokeStyle = this.colorDefault;\r\n  }\r\n\r\n  isEmpty(){\r\n    return this.lines.length == 0;\r\n  }\r\n\r\n  getLines(){\r\n    return this.lines;\r\n  }\r\n\r\n  undo(){\r\n    this.undoHistory.pop();\r\n\r\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    this.memCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n    // Grab the previous state, and copy it into both canvas\r\n    if(this.undoHistory.length > 0){\r\n      var prev = this.undoHistory[this.undoHistory.length - 1];\r\n      this.context.drawImage(prev, 0, 0);\r\n      this.memCtx.drawImage(prev, 0, 0);\r\n    }\r\n\r\n    let line = this.lines.pop();\r\n\r\n    if(this.onUndo != null)\r\n      this.onUndo(line, this);\r\n  }\r\n\r\n  init(){\r\n    this.points = [];\r\n    this.count = 0;\r\n    this.tempLine = [];\r\n    this.lines = [];\r\n    this.firstTimestamp = -1;\r\n  }\r\n\r\n  eventCanvas(ev) {\r\n    ev.point = {\r\n      x: ev.offsetX / this.canvas.offsetWidth,\r\n      y: ev.offsetY / this.canvas.offsetWidth\r\n    };\r\n    var func = this[ev.type].bind(this);\r\n    if (func)\r\n      func(ev);\r\n  }\r\n\r\n  // Pushes a new dot to the temporary line\r\n  addDotToTempLine(point){\r\n\r\n    let time = 0;\r\n\r\n    if(this.tempLine.length == 0 && this.lines.length == 0){\r\n      time = 0;\r\n      this.firstTimestamp = new Date().getTime();\r\n    } else {\r\n      time = new Date().getTime() - this.firstTimestamp;\r\n    }\r\n\r\n    point.timestamp = time;\r\n    this.tempLine.push(point);\r\n  }\r\n\r\n\r\n  finishLine(){\r\n\r\n    // Save state in history (creating a new canvas)\r\n    var canvasCopy = document.createElement('canvas');\r\n    canvasCopy.width = this.canvas.width;\r\n    canvasCopy.height = this.canvas.height;\r\n    var canvasCopyCtx = canvasCopy.getContext('2d');\r\n    canvasCopyCtx.drawImage(this.canvas, 0, 0);\r\n    this.undoHistory.push(canvasCopy);\r\n\r\n    // Push the new line to the line array\r\n    this.lines.push(this.tempLine);\r\n\r\n    // Clears temporary line\r\n    this.tempLine = [];\r\n    if(this.onFinishLine != null)\r\n      this.onFinishLine(this);\r\n  }\r\n\r\n\r\n  mousedown(ev) {\r\n    this.count = 0;\r\n    this.addDotToTempLine(ev.point);\r\n    this.renderer.drawDot(this.context, ev.point.x, ev.point.y);\r\n    this.memCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    this.memCtx.drawImage(this.canvas, 0, 0);\r\n    this.points.push(ev.point);\r\n    this.started = true;\r\n    this.renderer.drawPoints(this.context, this.points);\r\n  }\r\n\r\n  mousemove(ev) {\r\n\r\n    if(!this.started) return;\r\n\r\n    this.count++;\r\n    if(this.count == this.period){\r\n      this.addDotToTempLine(ev.point);\r\n      this.count = 0;\r\n    }\r\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    this.context.drawImage(this.memCanvas, 0, 0);\r\n    this.points.push(ev.point);\r\n    this.renderer.drawPoints(this.context, this.points);\r\n\r\n  }\r\n\r\n  mouseup(ev) {\r\n\r\n    if(!this.started) return;\r\n\r\n    this.started = false;\r\n    this.memCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    this.memCtx.drawImage(this.canvas, 0, 0);\r\n    this.points = [];\r\n    this.addDotToTempLine(ev.point);\r\n    this.finishLine();\r\n  }\r\n\r\n  mouseout(ev){\r\n    this.mouseup(ev);\r\n  }\r\n\r\n  clear() {\r\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    this.memCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    this.undoHistory = [];\r\n    this.init();\r\n\r\n    if(this.onClear != null)\r\n      this.onClear(this);\r\n  }\r\n\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/drawcanvas.js\n// module id = 0\n// module chunks = 0 1","'use strict';\r\n\r\nclass Util {\r\n  static rgb2hex(rgb){\r\n\r\n    var rgbRegex = new RegExp(/^rgb\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)$/);\r\n\r\n    var rgb = rgb.match(rgbRegex);\r\n\r\n    if(rgb == null)\r\n      return '#000000';\r\n\r\n    function process(component){\r\n      let c = Number(component);\r\n      if(c > 255) c = 255;\r\n      c = c.toString(16);\r\n      if(c.length == 1)\r\n        c = '0' + c;\r\n      return c;\r\n    }\r\n    return `#${process(rgb[1])}${process(rgb[2])}${process(rgb[3])}`;\r\n  }\r\n  \r\n\r\n  static getStyleProp(elem, prop){\r\n    if(window.getComputedStyle)\r\n      return window.getComputedStyle(elem, null).getPropertyValue(prop);\r\n    else if(elem.currentStyle)\r\n      return elem.currentStyle[prop];\r\n  }\r\n}\r\n\r\nmodule.exports = Util;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util.js\n// module id = 1\n// module chunks = 0 1","'use strict';\r\n\r\nclass Renderer {\r\n\r\n  constructor(canvas){\r\n    this.canvasWidth = canvas.width;\r\n  }\r\n\r\n  drawPoints(ctx, points) {\r\n    ctx.beginPath();\r\n\r\n    ctx.moveTo(points[0].x * this.canvasWidth, points[0].y * this.canvasWidth);\r\n    for (var i = 1; i < points.length - 2; i++) {\r\n        var c = ((points[i].x* this.canvasWidth) + (points[i + 1].x* this.canvasWidth)) / 2,\r\n            d = ((points[i].y * this.canvasWidth) + (points[i + 1].y * this.canvasWidth)) / 2;\r\n        ctx.quadraticCurveTo(points[i].x * this.canvasWidth, points[i].y * this.canvasWidth, c, d);\r\n    }\r\n    if(i < points.length - 1){\r\n      ctx.quadraticCurveTo(\r\n        points[i].x * this.canvasWidth,\r\n        points[i].y * this.canvasWidth,\r\n        points[i + 1].x * this.canvasWidth,\r\n        points[i + 1].y * this.canvasWidth);\r\n    }\r\n    ctx.stroke();\r\n  }\r\n\r\n\r\n  drawDot(ctx, x, y){\r\n    ctx.beginPath();\r\n    ctx.arc(x * this.canvasWidth, y * this.canvasWidth, ctx.lineWidth/2, 0, 2 * Math.PI, false);\r\n    ctx.fillStyle = ctx.strokeStyle;\r\n    ctx.fill();\r\n  }\r\n\r\n\r\n}\r\n\r\nmodule.exports = Renderer;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/renderer.js\n// module id = 2\n// module chunks = 0 1"],"sourceRoot":""}