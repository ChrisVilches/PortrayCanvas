{"version":3,"sources":["webpack:///webpack/bootstrap 45df36d14b686b577b45","webpack:///./src/portraycanvas.js","webpack:///./src/util.js","webpack:///./src/renderer.js"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,KAAK;QACL;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;QAEA;QACA;;;;;;;;AC7Da;;AAEb,WAAW,mBAAO,CAAC,CAAW;AAC9B,eAAe,mBAAO,CAAC,CAAe;;;AAGtC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,+CAA+C;AAC/C,8CAA8C;AAC9C,2CAA2C;AAC3C,gDAAgD;AAChD,8CAA8C;AAC9C,4CAA4C;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AChRa;;AAEb;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB,EAAE,gBAAgB,EAAE,gBAAgB;AACnE;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChCa;;AAEb;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"portraycanvas.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 45df36d14b686b577b45","'use strict';\n\nvar Util = require('./util.js');\nvar Renderer = require('./renderer.js');\n\n\nmodule.exports = class PortrayCanvas {\n\n  constructor(canvasDOM, options){\n\n    if(canvasDOM.hasOwnProperty('length')){\n      // It probably is a jQuery object\n      canvasDOM = canvasDOM[0];\n    }\n\n    if(canvasDOM.tagName.toLowerCase() !== 'canvas'){\n      throw new Error(\"Element is not a canvas.\");\n    }\n\n    this.canvas = canvasDOM;\n    this.context = this.canvas.getContext('2d');\n    this.started = false;\n    this.context.lineJoin = 'round';\n    this.context.lineCap = 'round';\n    this.memCanvas = document.createElement('canvas');\n    this.memCanvas.width = this.canvas.width;\n    this.memCanvas.height = this.canvas.height;\n    this.memCtx = this.memCanvas.getContext('2d');\n    this.undoHistory = [];\n\n    this.renderer = new Renderer(this.canvas);\n\n    this.init();\n    this.setOptions(options);\n    this.canvas.addEventListener('mousedown', this.eventCanvas.bind(this), false);\n    this.canvas.addEventListener('mousemove', this.eventCanvas.bind(this), false);\n    this.canvas.addEventListener('mouseup', this.eventCanvas.bind(this), false);\n    this.canvas.addEventListener('mouseout', this.eventCanvas.bind(this), false);\n    this.canvas.addEventListener('touchstart', this.eventCanvas.bind(this), false);\n    this.canvas.addEventListener('touchend', this.eventCanvas.bind(this), false);\n    this.canvas.addEventListener('touchmove', this.eventCanvas.bind(this), false);\n  }\n\n  drawLine(points){\n\n    // Add timestamps automatically\n    var time;\n    if(this.lines.length == 0){\n      time = 0;\n      this.firstTimestamp = new Date().getTime();\n    } else {\n      time = new Date().getTime() - this.firstTimestamp;\n    }\n    points.map(e => e.timestamp = time++);\n\n    this.tempLine = points;\n    this.renderer.drawPoints(this.context, points);\n    this.lineFinish();\n  }\n\n  setOptions(options){\n\n    this.context.strokeStyle = Util.rgb2hex(Util.getStyleProp(this.canvas, 'color'));\n    this.context.lineWidth = 5;\n    this.period = 5;\n    this.onLineFinish = null;\n    this.onClear = null;\n    this.onUndo = null;\n\n    if(typeof options !== 'object' || options == null) return;\n\n    if(typeof options.color === 'string')\n      this.context.strokeStyle = options.color;\n\n    if(typeof options.lineWidth === 'number')\n      this.context.lineWidth = options.lineWidth;\n\n    if(typeof options.period === 'number')\n      this.period = options.period;\n\n    if(typeof options.onLineFinish === 'function')\n      this.onLineFinish = options.onLineFinish;\n\n    if(typeof options.onClear === 'function')\n      this.onClear = options.onClear;\n\n    if(typeof options.onUndo === 'function')\n      this.onUndo = options.onUndo;\n\n    this.colorDefault = this.context.strokeStyle;\n  }\n\n  setColor(color){\n    this.context.strokeStyle = color;\n  }\n\n  revertDefaultColor(){\n    this.context.strokeStyle = this.colorDefault;\n  }\n\n  isEmpty(){\n    return this.lines.length == 0;\n  }\n\n  getLines(){\n    return this.lines;\n  }\n\n  undo(){\n    this.undoHistory.pop();\n\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.memCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Grab the previous state, and copy it into both canvas\n    if(this.undoHistory.length > 0){\n      var prev = this.undoHistory[this.undoHistory.length - 1];\n      this.context.drawImage(prev, 0, 0);\n      this.memCtx.drawImage(prev, 0, 0);\n    }\n\n    let line = this.lines.pop();\n\n    if(this.onUndo != null)\n      this.onUndo(line, this);\n  }\n\n  init(){\n    this.points = [];\n    this.count = 0;\n    this.tempLine = [];\n    this.lines = [];\n    this.firstTimestamp = -1;\n  }\n\n  eventCanvas(ev) {\n\n    let point = {};\n\n    // If these values are memoized, and the user resizes the window, the\n    // point position will become off (by a lot).\n    this.totalWidth = this.canvas.offsetWidth - this.borderHorizontal();\n    this.totalHeight = this.canvas.offsetHeight - this.borderVertical();\n\n    if(ev.type.charAt(0) === 't'){\n      // touch\n      var touch = ev.touches[0];\n\n      if(typeof touch === \"undefined\"){\n        point = this.currPoint;\n      } else {\n        var rect = this.canvas.getBoundingClientRect();\n\n        point.x = (touch.clientX - rect.left) / this.totalWidth;\n        point.y = (touch.clientY - rect.top) / this.totalHeight;\n      }\n\n    } else {\n      // mouse\n      point.x = ev.offsetX / this.totalWidth;\n      point.y = ev.offsetY / this.totalHeight;\n    }\n\n    this.currPoint = point;\n\n    switch(ev.type){\n\n      case 'mousedown': this.eventStart(point); break;\n      case 'mousemove': this.eventMove(point); break;\n      case 'mouseup': this.eventEnd(point); break;\n      case 'touchstart': this.eventStart(point); break;\n      case 'touchmove': this.eventMove(point); break;\n      case 'touchend': this.eventEnd(point); break;\n\n    }\n  }\n\n  // Gets the computed horizontal border width.\n  borderHorizontal(){\n    return this.borderWidth('left') + this.borderWidth('right');\n  }\n\n  // Gets the computed vertical border width.\n  borderVertical(){\n    return this.borderWidth('top') + this.borderWidth('bottom');\n  }\n\n  borderWidth(side){\n    var value = Util.getStyleProp(this.canvas, 'border-' + side + '-width') || '';\n    return +value.replace('px', '');\n  }\n\n  // Pushes a new dot to the temporary line\n  addDotToTempLine(point){\n\n    let time = 0;\n\n    if(this.tempLine.length == 0 && this.lines.length == 0){\n      time = 0;\n      this.firstTimestamp = new Date().getTime();\n    } else {\n      time = new Date().getTime() - this.firstTimestamp;\n    }\n\n    point.timestamp = time;\n    this.tempLine.push(point);\n  }\n\n  lineFinish(){\n\n    // Save state in history (creating a new canvas)\n    var canvasCopy = document.createElement('canvas');\n    canvasCopy.width = this.canvas.width;\n    canvasCopy.height = this.canvas.height;\n    var canvasCopyCtx = canvasCopy.getContext('2d');\n    canvasCopyCtx.drawImage(this.canvas, 0, 0);\n    this.undoHistory.push(canvasCopy);\n\n    // Push the new line to the line array\n    this.lines.push(this.tempLine);\n\n    // Clears temporary line\n    this.tempLine = [];\n    if(this.onLineFinish != null)\n      this.onLineFinish(this);\n  }\n\n  eventStart(point){\n    this.count = 0;\n    this.addDotToTempLine(point);\n    this.renderer.drawDot(this.context, point.x, point.y);\n    this.memCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.memCtx.drawImage(this.canvas, 0, 0);\n    this.points.push(point);\n    this.started = true;\n    this.renderer.drawPoints(this.context, this.points);\n  }\n\n  eventEnd(point){\n    if(!this.started) return;\n    this.started = false;\n    this.memCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.memCtx.drawImage(this.canvas, 0, 0);\n    this.points = [];\n    this.addDotToTempLine(point);\n    this.lineFinish();\n  }\n\n  eventMove(point){\n    if(!this.started) return;\n    this.count++;\n    if(this.count == this.period){\n      this.addDotToTempLine(point);\n      this.count = 0;\n    }\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.context.drawImage(this.memCanvas, 0, 0);\n    this.points.push(point);\n    this.renderer.drawPoints(this.context, this.points);\n  }\n\n\n  clear() {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.memCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.undoHistory = [];\n    this.init();\n\n    if(this.onClear != null)\n      this.onClear(this);\n  }\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/portraycanvas.js\n// module id = 0\n// module chunks = 0 1","'use strict';\n\nclass Util {\n  static rgb2hex(rgb){\n\n    var rgbRegex = new RegExp(/^rgb\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)$/);\n\n    var rgb = rgb.match(rgbRegex);\n\n    if(rgb == null)\n      return '#000000';\n\n    function process(component){\n      let c = Number(component);\n      if(c > 255) c = 255;\n      c = c.toString(16);\n      if(c.length == 1)\n        c = '0' + c;\n      return c;\n    }\n    return `#${process(rgb[1])}${process(rgb[2])}${process(rgb[3])}`;\n  }\n  \n\n  static getStyleProp(elem, prop){\n    if(window.getComputedStyle)\n      return window.getComputedStyle(elem, null).getPropertyValue(prop);\n    else if(elem.currentStyle)\n      return elem.currentStyle[prop];\n  }\n}\n\nmodule.exports = Util;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util.js\n// module id = 1\n// module chunks = 0 1","'use strict';\n\nclass Renderer {\n\n  constructor(canvas){\n    this.canvasWidth = canvas.width;\n    this.canvasHeight = canvas.height;\n  }\n\n  drawPoints(ctx, points) {\n\n    if(points.length == 2){\n      ctx.beginPath();\n      ctx.moveTo(points[0].x * this.canvasWidth, points[0].y * this.canvasHeight);\n      ctx.lineTo(points[1].x * this.canvasWidth, points[1].y * this.canvasHeight);\n      ctx.stroke();\n      return;\n    }\n\n    ctx.beginPath();\n\n    ctx.moveTo(points[0].x * this.canvasWidth, points[0].y * this.canvasHeight);\n    for (var i = 1; i < points.length - 2; i++) {\n        var c = ((points[i].x* this.canvasWidth) + (points[i + 1].x* this.canvasWidth)) / 2,\n            d = ((points[i].y * this.canvasHeight) + (points[i + 1].y * this.canvasHeight)) / 2;\n        ctx.quadraticCurveTo(points[i].x * this.canvasWidth, points[i].y * this.canvasHeight, c, d);\n    }\n    if(i < points.length - 1){\n      ctx.quadraticCurveTo(\n        points[i].x * this.canvasWidth,\n        points[i].y * this.canvasHeight,\n        points[i + 1].x * this.canvasWidth,\n        points[i + 1].y * this.canvasHeight);\n    }\n    ctx.stroke();\n  }\n\n  drawDot(ctx, x, y){\n    ctx.beginPath();\n    ctx.arc(x * this.canvasWidth, y * this.canvasHeight, ctx.lineWidth/2, 0, 2 * Math.PI, false);\n    ctx.fillStyle = ctx.strokeStyle;\n    ctx.fill();\n  }\n}\n\nmodule.exports = Renderer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/renderer.js\n// module id = 2\n// module chunks = 0 1"],"sourceRoot":""}